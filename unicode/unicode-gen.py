import re

version = '14.0'


def output(the_dict, name, filename, default, files):
    with open(filename, mode='w') as file:
        print(f'''// THIS IS A MACHINE GENERATED FILE, DO NOT EDIT MANUALLY
// Generated by unicode-gen.py according to Unicode Character Database
// Based on {files} of Unicode {version}
// See unicode-license.txt for the relevant copyright information

#include "unicode.hpp"
''', file=file)
        print('namespace Porkchop {', file=file)
        the_ranges = []
        the_range = []
        for key in sorted(the_dict):
            if not the_range:
                the_range = [key]
            elif (key == the_range[-1] + 1
                  and the_dict[key] == the_dict[the_range[0]]):
                the_range.append(key)
            else:
                the_ranges.append(the_range)
                the_range = [key]
        if the_range:
            the_ranges.append(the_range)

        del the_range

        print(f'static constexpr char32_t Unicode{name}RangeEnd[] = {{', end='', file=file)

        for index, the_range in enumerate(the_ranges):
            if index % 10 == 0:
                print(file=file)
                print(end='    ', file=file)
            print(f'0x{the_range[-1]:x}', end=', ', file=file)
        print(file=file)
        print('};', file=file)

        print(f'static constexpr unsigned char Unicode{name}Data[] = {{', end='', file=file)

        for index, the_range in enumerate(the_ranges):
            if index % 30 == 0:
                print(file=file)
                print(end='    ', file=file)
            print(f'{the_dict[the_range[-1]] if the_range[-1] in the_dict else 1}', end=', ', file=file)
        print(file=file)
        print('};', file=file)
        print('''
unsigned char getUnicodeWidth(char32_t ch) noexcept {
    if (ch <= UnicodeWidthRangeEnd[0]) [[likely]]
        return UnicodeWidthData[0];

    size_t first = 1;
    static const size_t last = std::size(UnicodeWidthRangeEnd);
    size_t len = last - first;
    do {
        size_t half = len >> 1;
        size_t middle = first + half;
        if (ch > UnicodeWidthRangeEnd[middle]) {
            first = middle + 1;
            len -= half + 1;
        } else {
            len = half;
        }
    } while (len);

    if (first != last) [[likely]]
        return UnicodeWidthData[first];
    return <default>;
}
'''.replace('Width', name).replace('<default>', default), file=file)
        print('}', file=file)


# unicode-width requires EastAsianWidth.txt PropList.txt UnicodeData.txt

width_dict = {}

with open('EastAsianWidth.txt', mode='r') as EAW:
    elines = [line.strip() for line in EAW
              if not re.match(r'.*<reserved-.+>\.\.<reserved-.+>.*', line)
              if re.match(r'^[^;]*;[WF]', line)]

for line in elines:
    fields = line.split(";")
    if '..' in fields[0]:
        code_points = fields[0].split("..")
    else:
        code_points = (fields[0], fields[0])
    for key in range(int(code_points[0], 16),
                     int(code_points[1], 16) + 1):
        width_dict[key] = 2

with open('UnicodeData.txt', mode='r') as UD:
    ulines = UD.readlines()

for line in ulines:
    fields = line.split(";")
    if fields[4] == "NSM" or fields[2] in ("Cf", "Me", "Mn"):
        width_dict[int(fields[0], 16)] = 0

with open('PropList.txt', mode='r') as PL:
    plines = [line.strip() for line in PL
              if re.match(r'^[^;]*;\s*Prepended_Concatenation_Mark', line)]

for line in plines:
    fields = line.split(";")
    if '..' in fields[0]:
        code_points = fields[0].split("..")
    else:
        code_points = (fields[0], fields[0])
    for key in range(int(code_points[0], 16),
                     int(code_points[1], 16) + 1):
        del width_dict[key]  # default width is 1

# special cases
del width_dict[0x00AD]  # default width is 1
for key in range(0x1160, 0x1200):
    width_dict[key] = 0
for key in range(0xD7B0, 0xD800):
    width_dict[key] = 0
for key in range(0x3248, 0x3250):
    width_dict[key] = 2
for key in list(range(0x4DC0, 0x4E00)):
    width_dict[key] = 2

for i in range(0, 0x10FFFF + 1):
    if i not in width_dict:
        width_dict[i] = 1


output(width_dict, 'Width', 'unicode-width.cpp', '1', 'EastAsianWidth.txt, PropList.txt and UnicodeData.txt')

# unicode-id requires DerivedCoreProperties.txt

id_start_set = set()
id_continue_set = set()

with open('DerivedCoreProperties.txt', mode='r') as DCP:
    dlines = [line.strip().split('#')[0] for line in DCP
              if re.match(r'^[^;]*; XID', line)]

for line in dlines:
    fields = line.split(";")
    if '..' in fields[0]:
        code_points = fields[0].split("..")
    else:
        code_points = (fields[0], fields[0])
    kind = fields[1].strip()
    for key in range(int(code_points[0], 16),
                     int(code_points[1], 16) + 1):
        if kind == "XID_Start":
            id_start_set.add(key)
        if kind == "XID_Continue":
            id_continue_set.add(key)

id_dict = {}

for key in range(0, 0x10FFFF + 1):
    id_dict[key] = 0
    if key in id_continue_set:
        id_dict[key] = 1
    if key in id_start_set:
        id_dict[key] = 2

output(id_dict, 'ID', 'unicode-id.cpp', '0', 'DerivedCoreProperties.txt')